1. 为客户端添加发牌和停牌功能
    子需求：清除切片		
	    直接重新赋值

    子需求：切片作为函数参数      
	    切片其实就是结构体，内含三个元素：len，cap，还有一个指向数组的指针，直接传参是值传递，
        虽然创建了一个新的切片，但是切片内的指针指向的是同一个数组，因此会出现很多奇怪的问题。
        比如说在函数内修改有用但是append会出现问题，因为你增加了一个元素，但是原来结构的len
        和cap没变，所以直接传递切片是很不推荐的，就算传递也只能读，不能修改，除非传递指针。
   
    子需求：如何解决代码冗余、
	    如果多个地方需要用到同一段代码，那么我们通常会把这段代码封装成一个函数，这样就可以解决
        代码冗余的方法，其实还有很多方法可以解决代码冗余，比如函数重载，多态等等。但是还有一种
        情况，就是为了实现功能需求，必须要在当前函数内执行某个操作，而这个操作在函数内会使用很
        多次，这种情况可以设置一个标记，在需要执行该操作的地方将标记置为true，然后在将操作放在
        函数末尾，标记起到了一个引流的作用，这样就在函数内解决了代码冗余。

2. 搞清楚四川麻将客户端的逻辑
    子需求：搞清楚 struct{} 的作用
	    首先，一个变量必定含有有两个基础元素，指针和指针指向的一块空间。struct{}类型的变量只有  
        指针，指针指向的值为空。所以它占用空间很少，可以用来占位，也就是说在我只关心有没有数据，
        而不关心数据的内容时，就可以用struct{}，也就是说只有1和无状态，甚至是没有0的。可以在
        以下的场景中使用struct{}：
	        1. 实现集合类型：Go里没有Set，可以用 map[int]struct{} 实现。insert就是st[k] = v，
            erase就是delete(st, k)，exist就是_, ok := st[k], return ok
	        2. 实现空通道：在进行多线程编程时，常常会用到通知型channel，其不需要发送任何数据，
            只是用于协调Gotoutine的运行，用于流转各类状态或是控制并发情况，这时就会用到struct{}。
            ch := make(chan struct{})  ch <- struct{}{}  case <- ch: 
	        3. 实现方法接收者：这通常用于程序开发初始阶段，我很明确的知道有个方法是有接收者的，
            但是由于程序的开发处于刚起步的状态，接收者的结构里有什么尚未可知，因此使用struct{}
            作为接收者，这样就便于后续的开发和维护，因为我能很清楚的知道哪个方法使用了这个结构。
            type T struct{}  func (t T) Print() { fmt.Println("哈哈哈") }
 
    子需求：多次重连会不会导致协程堆积？
        确实有可能，在client端的main函数里分出了两个协程，其中一个根据stopchan来退出，另一个
        根据连接是否存在退出，所以只需要在重连和退出时 stopchan <- struct{}{} 就行了，同时
        在退出时也要写 c.connection.Close()
    
    tip: 值传递是很麻烦的，因为很多结构里都有指针，值传递后指针指向的是同一个值，这会出现很多
        问题，而且Go里没有引用类型，所以大部分情况都要使用指针。

    子需求：测试log定向文件是否一直好用。
        log.SetOutput()应该是某个对象的设置，应该是全局有效的。不会因为跳函数或进协程
        就发生改变。

    子需求：重连和客户端设计冲突了，这个要处理一下
        我的重连思路是：在后台重连，游戏不退出。但是四川麻将的重连思路是：全部退出(但退的也不
        干净)，然后进行重连。这样就有了冲突。如果选择四川麻将的方案，那我RAL函数就要重写了。
        这就是对知识的不了解导致的开发成本吗，这个问题怎么规避呢？我也没办法提前把所有知识学完，
        那这就需要一个高效的框架，丰富的开发经验，深厚的知识以及大胆的想象力。
        说实话，重连就是获得一个新的connection，而我的TcpClient和其中的connection都是指针，
        所以完全可以以重新赋值connection的方式来重连，这样就可以后台重连了，也不会影响太多，
        可以一试。
    
    子需求：如果无缓存的通道已满，那么后续的数据是否会直接丢弃？
        不会丢弃，因为无缓存的通道在发送时会阻塞，知道有人接收才继续执行，也就是说每个放进
        无缓存通道的数据都不会被丢弃。其实不只是无缓存通道，就算有缓存通道，在缓存满的时候也会
        阻塞，也就是说放进通道里的数据是不会被丢弃的。

    子需求：Client重连和退出问题处理
        Client主要有四个协程，主协程，game协程，接收协程，心跳协程。现在game协程和心跳协程可能
        会发出重连请求，重连实际上就是为connection重新赋值。
        方案一：game协程和心跳协程的重连请求都跳到同一个函数去处理，这个思路没问题，但是这样做
        不好，可能会发生互斥问题，于是还是使用原来的方法，使用一个协程去监视重连通道，如果有重连
        请求再跳进重连函数。但是game的重连和heart的重连还不太一样，game是多次重连以求稳定，
        heart是重连一次，这个好像没什么影响，正常向重连通道传值就可以了。由于Read是一个阻塞操作，
        而且在重连时要关闭Read，那么就要在接收协程内检测重连信号，经过长时间周折，得出以下方法：
        在接收协程内另外开一个协程用于Read，Read协程有一个通道用来和接收协程交流，这样就可以在
        接收协程内检测重连信号了，如果stopChan内有消息，那么就conn.Close()，然后等待一会后重新
        Read，那么这就需要在重连时先<-StopChan, 再 <-RconnChan。退出的话就通过context来做，
        这个是能够实现的。不，Reconn信号我要在接收协程里来做，必须要等conn.Close()结束后再
        RConnChan <- true，然后在等待一段时间后再继续，那么那个StopChan这个名字就不合理了，应
        该改成ReConnChan，RconnChan改成ConnChan。

    子需求：Tick和NewTicker的区别？
        Tick就是将Ticker包装了一层，正常还是建议用Ticker

    子需求：取消匹配那里需要改一下。
        改完了，如果取消匹配就向服务端发送MatchOffPacket但却不接收数据，根据MatchPacket返回的
        结果判断是否取消匹配成功，这样做服务端那边的处理会更简单一些。

    实验：通道关闭后还会阻塞吗？
        不会，可以再关闭的通道内直接读，不会阻塞，但是读到的都是零值

    子需求：搞清楚Golang的变量生命周期
        Golang的生命周期和C++很不一样。内存是分堆和栈的，在C++中，函数内定义的变量
        在函数栈中，函数退出函数栈的变量也会自动释放，使用new分配的变量在堆中，需要
        手动释放。可在Golang中也是这样，Golang也有函数栈，但是并不是在函数中定义的
        变量都在函数栈中，如果变量有外部指针访问的话，那么这个变量就会存储在堆中，所
        以即使退出函数也不会释放，而堆中的变量不需要主动释放，垃圾回收器检测到堆内元
        素无法访问就会将其自动释放。也就是说，Golang程序员不需要去管变量存在堆或栈，
        也不用手动释放，不需要担心内存泄漏，按照逻辑直接写就行。但是要考虑到内存逃逸
        可能出现的问题。
        什么叫做按照逻辑写？就是如果换成C++的话，原来需要new的地方都不需要了。

3. 搞清楚四川麻将服务端的逻辑
    子需求：搞清楚什么是回归测试
        一直在听大家说回归回归的，其实一直不是很了解回归是什么东西，其实回归就是回归测试的意思，我
        平时写的东西体量比较小，一次改动包含多个需求，因此单测的必要不大并且难度较高，因此我是没有
        做任何测试的。回归测试就是在改动代码后，再进行一次原来的测试看一看新加的东西是否影响了原有
        的功能，并且修改测试，看看新加的功能是否有效。这就是回归测试，在软件开发中，往往要经历大量
        的回归测试。

    子需求：搞清楚Golang中 new 和 make 的区别
        这两个都是在初始化时要用到的，在C++中也有new，那就先来看看C++中的new和Golang中的new有
        什么区别吧，相同点：含义相同，都是创建一个新的变量，并返回该变量的指针。不同点：底层不同，
        C++通过new创建的变量是分配在堆上的，而Golang则不一定，主要看有没有外部指针能访问到这个
        变量，而且在Golang中没有构造函数，所以在new一个变量的时候会赋零值。由于在Golang中程序员
        不需要考虑内存分配的问题，所以任何创建变量的方式在底层来说都一样，new在Golang中并不是一个
        必要的关键字，这只是一个语法糖，我完全可以用其他的写法来代替new。
        而make只能用于slice, map和chan, make不是一个语法糖，他是必要的。
        为什么要为slice，map和chan专门定义一个make呢？因为这三个东西在使用之前就是必须要初始化的，
        如果不初始化就都是nil，如果是nil这三个东西都没法使用，除了slice，slice即使是nil也能使用，
        因为append函数可以对nil slice扩容。但是make给了slice一个设置初始容量的机会。
        可以用new来创建slice, map, chan，但值仍然是nil，还是用不了的，因此不推荐。我猜new的结果
        和 var x Type; p = &x 的效果是相同的。

    子需求：什么是语法糖？
        在其他语言或该语言中能够实现的功能，但是因为一个语法就快速解决了，这就是语法糖。比如
        select case, 在其他语言中实现可能要调各种库，但在Golang中直接就解决了。

    子需求：如何用一个端口处理不同的客户端的请求？
        当然是启用多个线程了，但是这样还是有问题，因为数据不是一下子全传输完的，他是一块一块传输的，
        如果所有线程都去监听端口来什么就读什么，那么线程就可能读到其他客户端的数据，因此要有一个
        分配的中间层，而对于每个线程需要一个用来读取和发送数据的虚拟端口，这就是socket。socket存
        有五个值，源IP, 源端口, 目的IP, 目的端口, 协议，用于区分不同的连接，当数据过来时，会根据他
        的IP地址以及端口信息将其分配到对应的socket，然后对应线程的read函数读取socket的数据。这样就
        实现了一个端口处理不同客户端的请求，要实现这一点，要求程序员拥有socket编程的能力，但如今由于
        各种框架的存在，socket编程已经简化为调用几个接口就能实现，比如accept(), read(), write()。

    子需求：你觉得Go相较于C++优缺点有哪些？为什么选择Go？

        
    子需求：学习Golang同步协程的几种方法？这个确实也是我之前一直困惑的点。
        参考文章：https://www.cnblogs.com/ailumiyana/p/11107835.html
                 https://blog.csdn.net/smilesundream/article/details/80209026
        实验：模拟一个互斥和死锁的情形
        tips：另外还要搞清楚线程通信和线程同步的区别

    子需求：学习线程的生产者-消费者模式
        tips：感觉和协程池的思想很像，试着写一个例子出来，实现一个简易的协程池
              公司的协程池就是自己写的，感觉可以参考一下
    
    子需求：学习设计模式知识，并挑一个合适的放在我的服务端代码中

    子需求：通过对象的方式使用依赖，使用依赖注入功能

    子需求：搞懂defer语句的执行顺序
    

4. 搞懂ants协程池，并构思服务端设计
    子需求：代码运行依据的是本地的代码还是github上的代码？
        需要做几次实验：
        本地更新，github上不更新，断网运行
            实验结果：
        本地更新，github上不更新，联网运行
            实验结果：
        本地更新commit，github不更新，断网运行
            实验结果：
        本地更新commit，github不更新，联网运行
            实验结果：
        本地更新push，删除本地代码，断网运行
            实验结果：
        本地更新push，删除本地代码，联网运行
            实验结果：















	
