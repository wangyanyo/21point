1. 为客户端添加发牌和停牌功能
    子需求：清除切片		
	    直接重新赋值

    子需求：切片作为函数参数      
	    切片其实就是结构体，内含三个元素：len，cap，还有一个指向数组的指针，直接传参是值传递，
        虽然创建了一个新的切片，但是切片内的指针指向的是同一个数组，因此会出现很多奇怪的问题。
        比如说在函数内修改有用但是append会出现问题，因为你增加了一个元素，但是原来结构的len
        和cap没变，所以直接传递切片是很不推荐的，就算传递也只能读，不能修改，除非传递指针。
   
    子需求：如何解决代码冗余、
	    如果多个地方需要用到同一段代码，那么我们通常会把这段代码封装成一个函数，这样就可以解决
        代码冗余的方法，其实还有很多方法可以解决代码冗余，比如函数重载，多态等等。但是还有一种
        情况，就是为了实现功能需求，必须要在当前函数内执行某个操作，而这个操作在函数内会使用很
        多次，这种情况可以设置一个标记，在需要执行该操作的地方将标记置为true，然后在将操作放在
        函数末尾，标记起到了一个引流的作用，这样就在函数内解决了代码冗余。

2. 搞清楚四川麻将客户端的逻辑
    子需求：搞清楚 struct{} 的作用
	    首先，一个变量必定含有有两个基础元素，指针和指针指向的一块空间。struct{}类型的变量只有  
        指针，指针指向的值为空。所以它占用空间很少，可以用来占位，也就是说在我只关心有没有数据，
        而不关心数据的内容时，就可以用struct{}，也就是说只有1和无状态，甚至是没有0的。可以在
        以下的场景中使用struct{}：
	        1. 实现集合类型：Go里没有Set，可以用 map[int]struct{} 实现。insert就是st[k] = v，
            erase就是delete(st, k)，exist就是_, ok := st[k], return ok
	        2. 实现空通道：在进行多线程编程时，常常会用到通知型channel，其不需要发送任何数据，
            只是用于协调Gotoutine的运行，用于流转各类状态或是控制并发情况，这时就会用到struct{}。
            ch := make(chan struct{})  ch <- struct{}{}  case <- ch: 
	        3. 实现方法接收者：这通常用于程序开发初始阶段，我很明确的知道有个方法是有接收者的，
            但是由于程序的开发处于刚起步的状态，接收者的结构里有什么尚未可知，因此使用struct{}
            作为接收者，这样就便于后续的开发和维护，因为我能很清楚的知道哪个方法使用了这个结构。
            type T struct{}  func (t T) Print() { fmt.Println("哈哈哈") }
 
    子需求：多次重连会不会导致协程堆积？
        确实有可能，在client端的main函数里分出了两个协程，其中一个根据stopchan来退出，另一个
        根据连接是否存在退出，所以只需要在重连和退出时 stopchan <- struct{}{} 就行了，同时
        在退出时也要写 c.connection.Close()
    
    tip: 值传递是很麻烦的，因为很多结构里都有指针，值传递后指针指向的是同一个值，这会出现很多
        问题，而且Go里没有引用类型，所以大部分情况都要使用指针。

    子需求：测试log定向文件是否一直好用。
        log.SetOutput()应该是某个对象的设置，应该是全局有效的。不会因为跳函数或进协程
        就发生改变。

    子需求：重连和客户端设计冲突了，这个要处理一下
        我的重连思路是：在后台重连，游戏不退出。但是四川麻将的重连思路是：全部退出(但退的也不
        干净)，然后进行重连。这样就有了冲突。如果选择四川麻将的方案，那我RAL函数就要重写了。
        这就是对知识的不了解导致的开发成本吗，这个问题怎么规避呢？我也没办法提前把所有知识学完，
        那这就需要一个高效的框架，丰富的开发经验，深厚的知识以及大胆的想象力。
        说实话，重连就是获得一个新的connection，而我的TcpClient和其中的connection都是指针，
        所以完全可以以重新赋值connection的方式来重连，这样就可以后台重连了，也不会影响太多，
        可以一试。
    
    子需求：如果无缓存的通道已满，那么后续的数据是否会直接丢弃？
        不会丢弃，因为无缓存的通道在发送时会阻塞，知道有人接收才继续执行，也就是说每个放进
        无缓存通道的数据都不会被丢弃。其实不只是无缓存通道，就算有缓存通道，在缓存满的时候也会
        阻塞，也就是说放进通道里的数据是不会被丢弃的。

    子需求：Client重连和退出问题处理
        Client主要有四个协程，主协程，game协程，接收协程，心跳协程。现在game协程和心跳协程可能
        会发出重连请求，重连实际上就是为connection重新赋值。
        方案一：game协程和心跳协程的重连请求都跳到同一个函数去处理，这个思路没问题，但是这样做
        不好，可能会发生互斥问题，于是还是使用原来的方法，使用一个协程去监视重连通道，如果有重连
        请求再跳进重连函数。但是game的重连和heart的重连还不太一样，game是多次重连以求稳定，
        heart是重连一次，这个好像没什么影响，正常向重连通道传值就可以了。由于Read是一个阻塞操作，
        而且在重连时要关闭Read，那么就要在接收协程内检测重连信号，经过长时间周折，得出以下方法：
        在接收协程内另外开一个协程用于Read，Read协程有一个通道用来和接收协程交流，这样就可以在
        接收协程内检测重连信号了，如果stopChan内有消息，那么就conn.Close()，然后等待一会后重新
        Read，那么这就需要在重连时先<-StopChan, 再 <-RconnChan。退出的话就通过context来做，
        这个是能够实现的。不，Reconn信号我要在接收协程里来做，必须要等conn.Close()结束后再
        RConnChan <- true，然后在等待一段时间后再继续，那么那个StopChan这个名字就不合理了，应
        该改成ReConnChan，RconnChan改成ConnChan。

    子需求：Tick和NewTicker的区别？
        Tick就是将Ticker包装了一层，正常还是建议用Ticker

    子需求：取消匹配那里需要改一下。
        改完了，如果取消匹配就向服务端发送MatchOffPacket但却不接收数据，根据MatchPacket返回的
        结果判断是否取消匹配成功，这样做服务端那边的处理会更简单一些。

    实验：通道关闭后还会阻塞吗？
        不会，可以再关闭的通道内直接读，不会阻塞，但是读到的都是零值

    子需求：搞清楚Golang的变量生命周期
        Golang的生命周期和C++很不一样。内存是分堆和栈的，在C++中，函数内定义的变量
        在函数栈中，函数退出函数栈的变量也会自动释放，使用new分配的变量在堆中，需要
        手动释放。可在Golang中也是这样，Golang也有函数栈，但是并不是在函数中定义的
        变量都在函数栈中，如果变量有外部指针访问的话，那么这个变量就会存储在堆中，所
        以即使退出函数也不会释放，而堆中的变量不需要主动释放，垃圾回收器检测到堆内元
        素无法访问就会将其自动释放。也就是说，Golang程序员不需要去管变量存在堆或栈，
        也不用手动释放，不需要担心内存泄漏，按照逻辑直接写就行。但是要考虑到内存逃逸
        可能出现的问题。
        什么叫做按照逻辑写？就是如果换成C++的话，原来需要new的地方都不需要了。

3. 搞清楚四川麻将服务端的逻辑
    子需求：搞清楚什么是回归测试
        一直在听大家说回归回归的，其实一直不是很了解回归是什么东西，其实回归就是回归测试的意思，我
        平时写的东西体量比较小，一次改动包含多个需求，因此单测的必要不大并且难度较高，因此我是没有
        做任何测试的。回归测试就是在改动代码后，再进行一次原来的测试看一看新加的东西是否影响了原有
        的功能，并且修改测试，看看新加的功能是否有效。这就是回归测试，在软件开发中，往往要经历大量
        的回归测试。

    子需求：搞清楚Golang中 new 和 make 的区别
        这两个都是在初始化时要用到的，在C++中也有new，那就先来看看C++中的new和Golang中的new有
        什么区别吧，相同点：含义相同，都是创建一个新的变量，并返回该变量的指针。不同点：底层不同，
        C++通过new创建的变量是分配在堆上的，而Golang则不一定，主要看有没有外部指针能访问到这个
        变量，而且在Golang中没有构造函数，所以在new一个变量的时候会赋零值。由于在Golang中程序员
        不需要考虑内存分配的问题，所以任何创建变量的方式在底层来说都一样，new在Golang中并不是一个
        必要的关键字，这只是一个语法糖，我完全可以用其他的写法来代替new。
        而make只能用于slice, map和chan, make不是一个语法糖，他是必要的。
        为什么要为slice，map和chan专门定义一个make呢？因为这三个东西在使用之前就是必须要初始化的，
        如果不初始化就都是nil，如果是nil这三个东西都没法使用，除了slice，slice即使是nil也能使用，
        因为append函数可以对nil slice扩容。但是make给了slice一个设置初始容量的机会。
        可以用new来创建slice, map, chan，但值仍然是nil，还是用不了的，因此不推荐。我猜new的结果
        和 var x Type; p = &x 的效果是相同的。

    子需求：什么是语法糖？
        在其他语言或该语言中能够实现的功能，但是因为一个语法就快速解决了，这就是语法糖。比如
        select case, 在其他语言中实现可能要调各种库，但在Golang中直接就解决了。

    子需求：如何用一个端口处理不同的客户端的请求？
        当然是启用多个线程了，但是这样还是有问题，因为数据不是一下子全传输完的，他是一块一块传输的，
        如果所有线程都去监听端口来什么就读什么，那么线程就可能读到其他客户端的数据，因此要有一个
        分配的中间层，而对于每个线程需要一个用来读取和发送数据的虚拟端口，这就是socket。socket存
        有五个值，源IP, 源端口, 目的IP, 目的端口, 协议，用于区分不同的连接，当数据过来时，会根据他
        的IP地址以及端口信息将其分配到对应的socket，然后对应线程的read函数读取socket的数据。这样就
        实现了一个端口处理不同客户端的请求，要实现这一点，要求程序员拥有socket编程的能力，但如今由于
        各种框架的存在，socket编程已经简化为调用几个接口就能实现，比如accept(), read(), write()。

    子需求：你觉得Go相较于C++优缺点有哪些？为什么选择Go？
        语言只是实现思考的工具，使用工具的工具。语言只是把脑内的抽象语言转换为机器能够执行的语言的
        工具而已，但是语言和语言之间还是有区别，不然的话为什么不用机器语言去写程序呢，那么多人使用
        高级语言肯定是有原因的。
        机器语言 -> 汇编语言：
            我觉得这只是一次集成，将常用到的命令集成在一起形成了一个个汇编指令，但是在编程时的思路
            是没有太大变化的，仍然是以指令为主。
        汇编语言 -> C语言：
            这是一次重大的转变，这是一个真正的语言，因为你不再需要去考虑指令级别的东西，而是只要考虑
            是否符合语法就行了，同时他也在汇编的基础上对一些功能进行了集成。把自己的思路转换成C语言
            是简单的，但还是有缺点，比如写大型项目时举步维艰。
        C语言 -> C++:
            明明已经把很多功能集成在一起了，可为什么还是在大型项目上举步维艰呢？这就要提两点，那就是
            程序员要考虑的面的大小以及代码的简洁程度，C语言是面向过程编程，先做什么，后做什么，那做
            这个事的主体是谁呢？是进程，而程序员在写程序时要将自己想象成进程，因此在构思大型项目中
            要考虑到很多方面，而且在修改时也要考虑更多，因此在写项目时就会举步维艰；而且大型项目不
            是一日之功，需要长期的开发，而C语言代码由于涉及全局，因此可读性较差，所以不利于长期的开
            发。而C++则彻底地改变了编程的思路，它为每一个方法都设置一个对象，并将相似的对象同属于
            一个类，而类可以继承，面向对象的思路更适合人类的思路，将成员封装可以让程序员在修改代码
            时考虑的东西更少，比如在修改私有成员时只需要考虑该类自己的方法即可，不需要考虑全局，
            继承能够让程序员从范型做起，通过继承使类型更加具体，也能让拥有相似属性的类拥有同样的
            行为，比如 可绘画物体 + 可移动物体 -> 坦克，子弹，这样只要实现可移动物体的移动方法，
            坦克和子弹就都可以移动了，而多态可以使代码更简洁，让代码更优雅，多态是继承的核心。

        Go语言：
            C++看起来已经完美了，那为什么其他的语言还会流行呢？C++在创立之初当时的网络还不发达，
            人们开发都是在开发一个大型项目，比如单机游戏，数据库，银行管理系统这种。在互联网场景
            下，需要能够轻松管理高并发，并且支持快速编写Web程序的语言。而C++在创立之初并没有照顾
            到这两方面，而且当前技术更新的很快，C++很难用到开源社区的新技术，因此C++逐渐落伍了，
            但是Java和Go能够支持高并发，同时也能快速开发Web程序，而且这两个语言都能很好的用到
            开源社区的新技术，Java还有个优势，那就是能运行在任何环境上，但是Go因为Docker的存在
            也能做到这一点，这正是Go优势的体现，Go能零成本的用到他人的技术，这使得Go的生态发展的
            非常快。因为大家都很容易就能用，所以会有更多人发现问题，那么这个东西就会越成熟。所以
            用Go语言不用担心会落伍。同时还有很多其他的语言比如html, json等有特殊功能和专属领域的
            语言，因此C++这一看似完美的语言渐渐地被人们放弃，但C++仍然有很大优势，比如快速简洁，
            可以用来写算法题。其实C++的思路就是最适合编程的思路，其他的语言因为过于抽象反而不适合
            写算法题。
        
    子需求：学习Golang同步协程的几种方法？这个确实也是我之前一直困惑的点。
        参考文章：https://www.cnblogs.com/ailumiyana/p/11107835.html
                 https://blog.csdn.net/smilesundream/article/details/80209026
        实验：模拟一个互斥和死锁的情形
        tips：另外还要搞清楚线程通信和线程同步的区别
        多线程有两个难题，一个是互斥资源的访问，另一个是线程的同步。首先是互斥资源的访问，如果只有
        读操作，那么无论如何都不会发生错误，但是除了读操作还有写操作，其实如果是原子的写入操作其实
        是没问题的，但是大多数的写入操作都被分成了两步，即先读后写，如果两个读写操作同时进行那就发
        生了更新丢失，这时候就要使用锁，我是推荐读写锁，即读和读之间不互斥，但是读和写之间、写和写
        之间是互斥的，在读操作前后加RLock()和RUnlock()，在写操作前后加上Lock()和Unlock()。
        然后就是线程的同步，这个主要是通过线程间的通信来实现，比如子线程全部退出后，主线程再继续执
        行，这个可以通过sync.WaitGroup实现，wg.Add(), defer wg.Done(), wg.Wait()，或者
        一个线程退出，其他线程也要一起退出，这个可以用context.Context来实现，context.WithCancel()
        cancel(), <- ctx.done()，协程什么时候退出？协程是否要阻塞等待另一个协程的数据，这些都是
        要通过通道进行控制的。
        
    子需求：搞懂defer语句的执行顺序
        每次遇到defer都会讲defer里的东西压入栈中，函数return语句结束后再按先进后出的顺序依次执行，
        func f() (res int) {
            defer fun(
                res = 1
            )
            x := 2
            return x + 1
        }
        则执行顺序是：res = x + 1, res = 1, return res，返回结果是 1

    子需求：搞懂什么是cookie
        为什么浏览器可以自动登录，是因为浏览器存储了cookie，在请求网页时顺带将cookie发了过去，服务器
        检测到cookie内是正确的账号密码，就自动登录了。
        cookie就是小型文本文件，由服务器创建，浏览器保存，cookie的表示是key-value的形式，存储在
        Header中，例：Cookie: username=root; jack=jack123 这种。可以设置cookie的生命周期，可以
        将其设置为会话性或持久性。cookie最常见的应用就是自动登录，当然也可以用作其他功能，毕竟这是
        一个小缓存，每次客户端的请求还都会把cookie发过来，利用他的特性还是能实现很多功能的。

    子需求：函数退出后，在函数内开的协程会退出吗？
        如果是主程序退出即main函数退出，那么所有协程都将被清理，如果只是循环块退出或普通函数退出，
        那么协程是不会终止的。因此对于协程的控制尤为重要。
        
    子需求：如何创建数据库并查看数据库名称？
        进入mysql的bin文件夹，打开终端输入cmd，然后输入mysql -u root -p，然后就可以输入mysql命令
        了，show databases; 是查看数据库，create database xxx; 是创建数据库。

    子需求：什么是init()函数？
        init()函数会在导入包时自动执行，可以用于初始化配置信息，或者初始化数据库。

    子需求：客户端的重连机制有问题，再改一下，注意通道的阻塞，
        而且重连后服务端不知道客户端的身份，解决这个问题。
        可以尝试类似seesion的方法，当然也可以想想其他办法。
        同时为接收数据加一个超时重连的功能，在CmdChan那里加，或者用context，也可以设置缓冲区
        最主要的就是一个游戏线程，还有一个接收数据线程，正常只需要这两个线程，但是连接可能会失效，
        所以我想加入一个在线重连和维持长连接的功能。为了实现长连接，我创建一个心跳线程，每十秒钟
        发送一次心跳，如果发送失败就申请重连，同样的如果游戏线程发送数据失败或者接收数据时间过长，
        都会发起重连请求。这里会有两个分支，一是如何安全的进行在线重连，即我在申请重连到连接重置
        这一段时间内如何保证各个通道和互斥条件是安全的，因为这段时间内我会关闭连接，并且重新给连接
        赋值，这段时间内我是不允许其他线程使用连接的，还有如果通道数据和超时计时同时来到，我选择了
        超时重连，这时就会发生通道死锁，如果关闭通道就会panic，这一点可以尝试使用缓冲区，但这并不是
        完美的方案。二是聊天功能究竟是用拉模式还是推模式，两个都各有优缺点，这个还要更细致的考虑。
    
    子需求：C++多态和Go语言interface的区别？
        interface其实就是把C++的纯虚函数的特性剥离了出来，其实想要实现多态interface就够了，
        但是C++为了面向对象的特性和适应继承保留了一些多余的东西，纯虚函数和interface的共同点
        是二者都没有实体，并且想要使用多态特性的话必须要实现其全部函数，不同点是interface是全
        自动的，也不局限于指针和引用。总之interface是多态的下限，是单纯为多态而设计的，但C++的
        纯虚函数还要为继承和面向对象服务，因此增加了一些东西。

    子需求：参考上面重新构思客户端的整个架构，重连时注意互斥问题，可以尝试用锁。

    子需求：重连后服务端不知道客户端的身份，解决这个问题。

    子需求：为客户端接收数据添加一个超时重连功能，为避免通道死锁可考虑加入缓冲区，再想想其他办法。

    子需求：考虑聊天是使用拉模式还是推模式，两者各有优缺点。

    子需求：为客户端设计聊天界面。

    子需求：尝试用Redis的ZSet去制作排行榜。

    子需求：搞懂什么是数据库连接池

    子需求：如何解决读写锁的写锁饥饿问题？
        第一步：参考操作系统是如何解决饥饿问题的。

    子需求：ants协程池的使用场景及其对应的使用方法。
        到底是什么场景会用到协程池？到底是什么需求会用到协程池？
        Go语言的HTTP包，每一个新的连接就会建立一个新的协程，如果有公司使用的是Go语言的net/http,
        那么在面对大量连接请求时就会造成协程过多，

    子需求：其实没必要用长连接，用短连接就可以，然后就可以用到协程池的第一个使用场景。
        面试官问到的时候，我还可以顺便说出ants的第二个使用场景。
        
    实验：服务端关闭连接后，客户端这边的连接还有效吗？
        连接其实就是存储了对方的状态，IP地址端口这些，即使服务端断开连接应该也是可以再找到的，
        但是连接还要建socket，服务端断开连接同时也把socket干掉了，而客户端的socket是和服务
        端的socket对应的，但是socket中存的就只有自己和对方的IP地址和端口，还有协议名，客户端
        即使重置连接自己的socket也没变，对方会不会自动创建一个socket呢？不知道，具体还要看实验
        结果。根据实验结果，想出一个可行的短连接方案。
        实验结束，重新理一遍，什么是连接，什么是网络。报文是发送到网络的，他不是直接发送到目的地，
        因此无论是客户端还是服务端在发送报文时都是不知道对方的状态的，想要知道对方的状态就必须接收
        并读取对方发来的信息。什么是连接呢？连接就是存储了目的地的IP地址和端口还有协议，还有其他
        的一些状态，这就是连接。用C++来说连接就是一个结构体，是访问目的IP时要用到的参数，在连接后
        会进行一些修改。更具体一点就是客户端和服务端两边各有一个Socket，二者相互对应，如果服务端的
        net.Conn被GC干掉，那么服务端的socket也会被干掉，而客户端仍然可以发送数据，因为客户端是向
        网络中发送数据，而网络是正常的，但是客户端却没有相应的Socket去接收数。
        实验结论：1. 服务端连接被回收后，客户端这边的连接还存在，但是发送的数据服务端收不到了。
                2. 连接本质上就是结构体，里面存储了本地和目的地的信息。
                3. 数据都是发到网络上，也是从网络上接收的，双方是不知道对方的状态的。
    
    实验：net.Conn是四次挥手吗？会对对方的连接造成影响吗？
        实验结束，结论：net.Conn只会关闭自己的连接，并不是四次挥手，不会影响到对方的连接。
        那么这样的话短连接的框架就明晰了，知道怎么写了。

    子需求：为什么不是基于http而是基于tcp实现这个项目呢？
        其中有一点是因为接触更多底层的东西能让我学到更多，比如socket编程，比如ants控制连接数量，
        比如长连接短连接如何取舍，究竟什么是连接呢？这些等等，还有第二点，可以参考这个文章，
        https://cloud.tencent.com/developer/article/1675493

    子需求：读ants原生文章，并作总结。
        地址：https://segmentfault.com/a/1190000015464889














	
