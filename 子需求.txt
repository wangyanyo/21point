1. 为客户端添加发牌和停牌功能
    子需求：清除切片		
	    直接重新赋值

    子需求：切片作为函数参数      
	    切片其实就是结构体，内含三个元素：len，cap，还有一个指向数组的指针，直接传参是值传递，
        虽然创建了一个新的切片，但是切片内的指针指向的是同一个数组，因此会出现很多奇怪的问题。
        比如说在函数内修改有用但是append会出现问题，因为你增加了一个元素，但是原来结构的len
        和cap没变，所以直接传递切片是很不推荐的，就算传递也只能读，不能修改，除非传递指针。
   
    子需求：如何解决代码冗余、
	    如果多个地方需要用到同一段代码，那么我们通常会把这段代码封装成一个函数，这样就可以解决
        代码冗余的方法，其实还有很多方法可以解决代码冗余，比如函数重载，多态等等。但是还有一种
        情况，就是为了实现功能需求，必须要在当前函数内执行某个操作，而这个操作在函数内会使用很
        多次，这种情况可以设置一个标记，在需要执行该操作的地方将标记置为true，然后在将操作放在
        函数末尾，标记起到了一个引流的作用，这样就在函数内解决了代码冗余。

2. 搞清楚四川麻将客户端的逻辑
    子需求：搞清楚 struct{} 的作用
	    首先，一个变量必定含有有两个基础元素，指针和指针指向的一块空间。struct{}类型的变量只有  
        指针，指针指向的值为空。所以它占用空间很少，可以用来占位，也就是说在我只关心有没有数据，
        而不关心数据的内容时，就可以用struct{}，也就是说只有1和无状态，甚至是没有0的。可以在
        以下的场景中使用struct{}：
	        1. 实现集合类型：Go里没有Set，可以用 map[int]struct{} 实现。insert就是st[k] = v，
            erase就是delete(st, k)，exist就是_, ok := st[k], return ok
	        2. 实现空通道：在进行多线程编程时，常常会用到通知型channel，其不需要发送任何数据，
            只是用于协调Gotoutine的运行，用于流转各类状态或是控制并发情况，这时就会用到struct{}。
            ch := make(chan struct{})  ch <- struct{}{}  case <- ch: 
	        3. 实现方法接收者：这通常用于程序开发初始阶段，我很明确的知道有个方法是有接收者的，
            但是由于程序的开发处于刚起步的状态，接收者的结构里有什么尚未可知，因此使用struct{}
            作为接收者，这样就便于后续的开发和维护，因为我能很清楚的知道哪个方法使用了这个结构。
            type T struct{}  func (t T) Print() { fmt.Println("哈哈哈") }
 
    子需求：多次重连会不会导致协程堆积？
        确实有可能，在client端的main函数里分出了两个协程，其中一个根据stopchan来退出，另一个
        根据连接是否存在退出，所以只需要在重连和退出时 stopchan <- struct{}{} 就行了，同时
        在退出时也要写 c.connection.Close()
    
    tip: 值传递是很麻烦的，因为很多结构里都有指针，值传递后指针指向的是同一个值，这会出现很多
        问题，而且Go里没有引用类型，所以大部分情况都要使用指针。

    子需求：测试log定向文件是否一直好用。
        log.SetOutput()应该是某个对象的设置，应该是全局有效的。不会因为跳函数或进协程
        就发生改变。

    子需求：重连和客户端设计冲突了，这个要处理一下
        我的重连思路是：在后台重连，游戏不退出。但是四川麻将的重连思路是：全部退出(但退的也不
        干净)，然后进行重连。这样就有了冲突。如果选择四川麻将的方案，那我RAL函数就要重写了。
        这就是对知识的不了解导致的开发成本吗，这个问题怎么规避呢？我也没办法提前把所有知识学完，
        那这就需要一个高效的框架，丰富的开发经验，深厚的知识以及大胆的想象力。
        说实话，重连就是获得一个新的connection，而我的TcpClient和其中的connection都是指针，
        所以完全可以以重新赋值connection的方式来重连，这样就可以后台重连了，也不会影响太多，
        可以一试。
    
    子需求：如果无缓存的通道已满，那么后续的数据是否会直接丢弃？
        不会丢弃，因为无缓存的通道在发送时会阻塞，知道有人接收才继续执行，也就是说每个放进
        无缓存通道的数据都不会被丢弃。其实不只是无缓存通道，就算有缓存通道，在缓存满的时候也会
        阻塞，也就是说放进通道里的数据是不会被丢弃的。

    子需求：Client重连和退出问题处理
        Client主要有四个协程，主协程，game协程，接收协程，心跳协程。现在game协程和心跳协程可能
        会发出重连请求，重连实际上就是为connection重新赋值。
        方案一：game协程和心跳协程的重连请求都跳到同一个函数去处理，这个思路没问题，但是这样做
        不好，可能会发生互斥问题，于是还是使用原来的方法，使用一个协程去监视重连通道，如果有重连
        请求再跳进重连函数。但是game的重连和heart的重连还不太一样，game是多次重连以求稳定，
        heart是重连一次，这个好像没什么影响，正常向重连通道传值就可以了。由于Read是一个阻塞操作，
        而且在重连时要关闭Read，那么就要在接收协程内检测重连信号，经过长时间周折，得出以下方法：
        在接收协程内另外开一个协程用于Read，Read协程有一个通道用来和接收协程交流，这样就可以在
        接收协程内检测重连信号了，如果stopChan内有消息，那么就conn.Close()，然后等待一会后重新
        Read，那么这就需要在重连时先<-StopChan, 再 <-RconnChan。退出的话就通过context来做，
        这个是能够实现的。不，Reconn信号我要在接收协程里来做，必须要等conn.Close()结束后再
        RConnChan <- true，然后在等待一段时间后再继续，那么那个StopChan这个名字就不合理了，应
        该改成ReConnChan，RconnChan改成ConnChan。

    子需求：Tick和NewTicker的区别？
        Tick就是将Ticker包装了一层，正常还是建议用Ticker

    子需求：取消匹配那里需要改一下。
        改完了，如果取消匹配就向服务端发送MatchOffPacket但却不接收数据，根据MatchPacket返回的
        结果判断是否取消匹配成功，这样做服务端那边的处理会更简单一些。

    实验：通道关闭后还会阻塞吗？
        不会，可以再关闭的通道内直接读，不会阻塞，但是读到的都是零值

    子需求：搞清楚Golang的变量生命周期
        Golang的生命周期和C++很不一样。内存是分堆和栈的，在C++中，函数内定义的变量
        在函数栈中，函数退出函数栈的变量也会自动释放，使用new分配的变量在堆中，需要
        手动释放。可在Golang中也是这样，Golang也有函数栈，但是并不是在函数中定义的
        变量都在函数栈中，如果变量有外部指针访问的话，那么这个变量就会存储在堆中，所
        以即使退出函数也不会释放，而堆中的变量不需要主动释放，垃圾回收器检测到堆内元
        素无法访问就会将其自动释放。也就是说，Golang程序员不需要去管变量存在堆或栈，
        也不用手动释放，不需要担心内存泄漏，按照逻辑直接写就行。但是要考虑到内存逃逸
        可能出现的问题。
        什么叫做按照逻辑写？就是如果换成C++的话，原来需要new的地方都不需要了。

3. 搞清楚四川麻将服务端的逻辑
    子需求：搞清楚什么是回归测试
        一直在听大家说回归回归的，其实一直不是很了解回归是什么东西，其实回归就是回归测试的意思，我
        平时写的东西体量比较小，一次改动包含多个需求，因此单测的必要不大并且难度较高，因此我是没有
        做任何测试的。回归测试就是在改动代码后，再进行一次原来的测试看一看新加的东西是否影响了原有
        的功能，并且修改测试，看看新加的功能是否有效。这就是回归测试，在软件开发中，往往要经历大量
        的回归测试。

    子需求：搞清楚Golang中 new 和 make 的区别
        这两个都是在初始化时要用到的，在C++中也有new，那就先来看看C++中的new和Golang中的new有
        什么区别吧，相同点：含义相同，都是创建一个新的变量，并返回该变量的指针。不同点：底层不同，
        C++通过new创建的变量是分配在堆上的，而Golang则不一定，主要看有没有外部指针能访问到这个
        变量，而且在Golang中没有构造函数，所以在new一个变量的时候会赋零值。由于在Golang中程序员
        不需要考虑内存分配的问题，所以任何创建变量的方式在底层来说都一样，new在Golang中并不是一个
        必要的关键字，这只是一个语法糖，我完全可以用其他的写法来代替new。
        而make只能用于slice, map和chan, make不是一个语法糖，他是必要的。
        为什么要为slice，map和chan专门定义一个make呢？因为这三个东西在使用之前就是必须要初始化的，
        如果不初始化就都是nil，如果是nil这三个东西都没法使用，除了slice，slice即使是nil也能使用，
        因为append函数可以对nil slice扩容。但是make给了slice一个设置初始容量的机会。
        可以用new来创建slice, map, chan，但值仍然是nil，还是用不了的，因此不推荐。我猜new的结果
        和 var x Type; p = &x 的效果是相同的。

    子需求：什么是语法糖？
        在其他语言或该语言中能够实现的功能，但是因为一个语法就快速解决了，这就是语法糖。比如
        select case, 在其他语言中实现可能要调各种库，但在Golang中直接就解决了。

    子需求：如何用一个端口处理不同的客户端的请求？
        当然是启用多个线程了，但是这样还是有问题，因为数据不是一下子全传输完的，他是一块一块传输的，
        如果所有线程都去监听端口来什么就读什么，那么线程就可能读到其他客户端的数据，因此要有一个
        分配的中间层，而对于每个线程需要一个用来读取和发送数据的虚拟端口，这就是socket。socket存
        有五个值，源IP, 源端口, 目的IP, 目的端口, 协议，用于区分不同的连接，当数据过来时，会根据他
        的IP地址以及端口信息将其分配到对应的socket，然后对应线程的read函数读取socket的数据。这样就
        实现了一个端口处理不同客户端的请求，要实现这一点，要求程序员拥有socket编程的能力，但如今由于
        各种框架的存在，socket编程已经简化为调用几个接口就能实现，比如accept(), read(), write()。

    子需求：你觉得Go相较于C++优缺点有哪些？为什么选择Go？
        语言只是实现思考的工具，使用工具的工具。语言只是把脑内的抽象语言转换为机器能够执行的语言的
        工具而已，但是语言和语言之间还是有区别，不然的话为什么不用机器语言去写程序呢，那么多人使用
        高级语言肯定是有原因的。
        机器语言 -> 汇编语言：
            我觉得这只是一次集成，将常用到的命令集成在一起形成了一个个汇编指令，但是在编程时的思路
            是没有太大变化的，仍然是以指令为主。
        汇编语言 -> C语言：
            这是一次重大的转变，这是一个真正的语言，因为你不再需要去考虑指令级别的东西，而是只要考虑
            是否符合语法就行了，同时他也在汇编的基础上对一些功能进行了集成。把自己的思路转换成C语言
            是简单的，但还是有缺点，比如写大型项目时举步维艰。
        C语言 -> C++:
            明明已经把很多功能集成在一起了，可为什么还是在大型项目上举步维艰呢？这就要提两点，那就是
            程序员要考虑的面的大小以及代码的简洁程度，C语言是面向过程编程，先做什么，后做什么，那做
            这个事的主体是谁呢？是进程，而程序员在写程序时要将自己想象成进程，因此在构思大型项目中
            要考虑到很多方面，而且在修改时也要考虑更多，因此在写项目时就会举步维艰；而且大型项目不
            是一日之功，需要长期的开发，而C语言代码由于涉及全局，因此可读性较差，所以不利于长期的开
            发。而C++则彻底地改变了编程的思路，它为每一个方法都设置一个对象，并将相似的对象同属于
            一个类，而类可以继承，面向对象的思路更适合人类的思路，将成员封装可以让程序员在修改代码
            时考虑的东西更少，比如在修改私有成员时只需要考虑该类自己的方法即可，不需要考虑全局，
            继承能够让程序员从范型做起，通过继承使类型更加具体，也能让拥有相似属性的类拥有同样的
            行为，比如 可绘画物体 + 可移动物体 -> 坦克，子弹，这样只要实现可移动物体的移动方法，
            坦克和子弹就都可以移动了，而多态可以使代码更简洁，让代码更优雅，多态是继承的核心。

        Go语言：
            C++看起来已经完美了，那为什么其他的语言还会流行呢？C++在创立之初当时的网络还不发达，
            人们开发都是在开发一个大型项目，比如单机游戏，数据库，银行管理系统这种。在互联网场景
            下，需要能够轻松管理高并发，并且支持快速编写Web程序的语言。而C++在创立之初并没有照顾
            到这两方面，而且当前技术更新的很快，C++很难用到开源社区的新技术，因此C++逐渐落伍了，
            但是Java和Go能够支持高并发，同时也能快速开发Web程序，而且这两个语言都能很好的用到
            开源社区的新技术，Java还有个优势，那就是能运行在任何环境上，但是Go因为Docker的存在
            也能做到这一点，这正是Go优势的体现，Go能零成本的用到他人的技术，这使得Go的生态发展的
            非常快。因为大家都很容易就能用，所以会有更多人发现问题，那么这个东西就会越成熟。所以
            用Go语言不用担心会落伍。同时还有很多其他的语言比如html, json等有特殊功能和专属领域的
            语言，因此C++这一看似完美的语言渐渐地被人们放弃，但C++仍然有很大优势，比如快速简洁，
            可以用来写算法题。其实C++的思路就是最适合编程的思路，其他的语言因为过于抽象反而不适合
            写算法题。

        
        
    子需求：学习Golang同步协程的几种方法？这个确实也是我之前一直困惑的点。
        参考文章：https://www.cnblogs.com/ailumiyana/p/11107835.html
                 https://blog.csdn.net/smilesundream/article/details/80209026
        实验：模拟一个互斥和死锁的情形
        tips：另外还要搞清楚线程通信和线程同步的区别
        多线程有两个难题，一个是互斥资源的访问，另一个是线程的同步。首先是互斥资源的访问，如果只有
        读操作，那么无论如何都不会发生错误，但是除了读操作还有写操作，其实如果是原子的写入操作其实
        是没问题的，但是大多数的写入操作都被分成了两步，即先读后写，如果两个读写操作同时进行那就发
        生了更新丢失，这时候就要使用锁，我是推荐读写锁，即读和读之间不互斥，但是读和写之间、写和写
        之间是互斥的，在读操作前后加RLock()和RUnlock()，在写操作前后加上Lock()和Unlock()。
        然后就是线程的同步，这个主要是通过线程间的通信来实现，比如子线程全部退出后，主线程再继续执
        行，这个可以通过sync.WaitGroup实现，wg.Add(), defer wg.Done(), wg.Wait()，或者
        一个线程退出，其他线程也要一起退出，这个可以用context.Context来实现，context.WithCancel()
        cancel(), <- ctx.done()，协程什么时候退出？协程是否要阻塞等待另一个协程的数据，这些都是
        要通过通道进行控制的。

    子需求：学习线程的生产者-消费者模式
        tips：感觉和协程池的思想很像，试着写一个例子出来，实现一个简易的协程池
              公司的协程池就是自己写的，感觉可以参考一下
        
    
    子需求：学习设计模式知识，并挑一个合适的放在我的服务端代码中

    子需求：通过对象的方式使用依赖，使用依赖注入功能

    子需求：搞懂defer语句的执行顺序
        每次遇到defer都会讲defer里的东西压入栈中，函数return语句结束后再按先进后出的顺序依次执行，
        func f() (res int) {
            defer fun(
                res = 1
            )
            x := 2
            return x + 1
        }
        则执行顺序是：res = x + 1, res = 1, return res，返回结果是 1

    子需求：搞懂什么是cookie

    子需求：搞清楚为什么公司代码里有server池和dao池，有什么用？

    子需求：C++多态和interface{}的区别？

    子需求：函数退出后，在函数内开的协程会退出吗？
        如果是主程序退出即main函数退出，那么所有协程都将被清理，如果只是循环块退出或普通函数退出，
        那么协程是不会终止的。因此对于协程的控制尤为重要。


4. 搞懂ants协程池，并构思服务端设计，理解公司的协程池设计
    子需求：代码运行依据的是本地的代码还是github上的代码？
        需要做几次实验：
        本地更新，github上不更新，断网运行
            实验结果：
        本地更新，github上不更新，联网运行
            实验结果：
        本地更新commit，github不更新，断网运行
            实验结果：
        本地更新commit，github不更新，联网运行
            实验结果：
        本地更新push，删除本地代码，断网运行
            实验结果：
        本地更新push，删除本地代码，联网运行
            实验结果：















	
